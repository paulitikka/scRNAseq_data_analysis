
---
title: "scRNAseq Analysis"
author: "Pauli Tikka"
date: "`r Sys.Date()`"
output: 
 rmdformats::downcute: #note the ':' it is needed: https://stackoverflow.com/questions/43527520/r-markdown-yaml-scanner-error-mapping-values
  self_contained: true
  thumbnails: true
  lightbox: true
  gallery: false
  highlight: tango
  # code_folding: show
  # fig.align = 'left'


---

# Introduction
```{r, warning=FALSE,message=FALSE}

# Welcome to the 'scRNAseq data analysis' webpage! 

# The procedures and explanations to make all the analysis and plots are in their individual chapters below. 
# These methods could be also easily applied to other types of data sets and metabolites than 'tooth metabolites' and their respective metadata per se. 
# In addition, there is a small 'disclaimer' also at the end of this webpage to emphasize that this site is mainly for educational purposes.
# Please let me know if you have any questions. For that, use the 'following' email: patati at the university of Turku

```

# Loading All R Packages
```{r, warning=FALSE,message=FALSE}
library(rlang); library(dplyr); #Error: package 'rtracklayer' could not be loaded, Error: (converted from warning) package 'rlang' was built under R version 4.2.3
library(BSgenome);library(eisaR);library(GenomicFeatures);library(tximeta);
library(rjson);library(reticulate);library(scater);
library(jsonlite);library(R6);library(loomR);library(LoomExperiment); 
library(SeuratDisk);library(sf); library(checkmate);library(tidyr) 
library("monocle3"); #copy pasted older and it seemed to work,,,
library(AUCell);library(SCENIC);library(GENIE3);library('xgboost');library(KernSmooth);
library(plotly);library(BiocParallel);library(data.table);library(doSNOW);library(doParallel);
library(Rmpi);library(doMPI);library(SMITE);library(Seurat);library(SeuratData);library(SCopeLoomR);library(biomaRt);library(singleCellTK);library(tools);library(scclusteval) #
library(VISION); library(zellkonverter);library(scRNAseq);library(org.Mm.eg.db);library(AnnotationDbi);library(IntEREst); library(janitor);
library(COSG);library(scMerge);library("htmltools");library(R.utils);library(xlsx);# library(m3adgfdon);
library(monocle);library(scrubletR);suppressMessages(require(DoubletFinder));library(scDblFinder);library(DoubletDecon); library(VennDiagram);library(pathviewr)
library(SeuratWrappers);library(patchwork);library(popsicleR);library("proxy");library("spatstat.geom")
library(SeuratDisk);library(rhdf5);library(qdapRegex);library(demCore) #library(Giotto);
library(tidyverse);library(sleepwalk);library(umap);library(BiocIO);library(rhdf5);library(MASS);library(gplots);library(SCINA);library(nichenetr)
library(hdf5r);library(stringi);library(Rcpp);library(harmony);library(limma);library(stats4);library(parallel);library(BiocGenerics);library(S4Vectors);
library(IRanges);library(GenomeInfoDb);library(GenomicRanges);library(Matrix);library(Biobase);library(matrixStats);library(MatrixGenerics);library(SummarizedExperiment);
library(lpSolve);library(ROI);library(rcbc);library(ROI.plugin.glpk);require(tidyverse);require(ROI.plugin.symphony);require(ompr);require(ompr.roi)
library(SingleCellExperiment);library(DESeq2);library(usethis);library(devtools);library(runjags);require(openxlsx)
library(reshape2);library(PRROC);library(WriteXLS);library(rpart);library(rpart.plot);library('lpsymphony')
set.seed(1234);library(stringr);library(rlist);library(gdata);library(splines);library(factoextra);library(cluster);library(VGAM);library(scuttle);library(scran);library(scater)
library(glmGamPoi);library(RColorBrewer);library(ggplot2);library(bit);library(bit64);library(stats4);library(lattice);library(SingleCellExperiment); library(BayesSpace)
library(Rmisc);library(XVector);library(Biostrings);library(Rsamtools);#library(Signac);
library(shiny);library(Matrix);library(patchwork);library(Factoshiny)
library("org.Hs.eg.db");library(grid);library(circlize); library(SparkR);library(base);library(namespace);library(BH) ;library(conos);library(affyio);library(ArrayExpress);library(oligo);
library(trendsceek);library(runjags);library(ggthemes);library(ggbeeswarm);library(destiny);library(slingshot);library(gtools);library(ggraph);library(clustree)
require(scales);require(scran);require(cowplot);library(sctransform);library(affy); library(hrbrthemes)
library(clustifyr); library(FactoMineR); library(missMDA); library(FactoInvestigate)
library(BiocManager);library(usethis);library(devtools);library(leidenbase);library(scDblFinder);library(parallelDist);library(ggvenn);library(sparklyr)
library('igraph') ;library('future') ;library('future.apply');library('pbapply') ;library('irlba'); library(caret) 
library('NMF');library('ggalluvial') ;library('stringr');library('svglite');library('expm'); library(VennDiagram);library(ggvenn);
library(SpatialExperiment) ;library('Rtsne');library('ggrepel') ;library('circlize');library('cowplot');library('ComplexHeatmap') ;library('RSpectra') 
library('Rcpp');library('RcppEigen');library('reticulate');library('scales') ;library('sna') ;library('forcats') ;library('reshape2') ;library('FNN') ;library('shape') 
library('BiocGenerics');library('magrittr') ;library('colorspace') ;library('plyr');library(patchwork);options(stringsAsFactors = FALSE)
library(presto);library(ggpubr);library(png);library(magick);require(dplyr);require(magick);require(cowplot);
library(caret);library(AppliedPredictiveModeling); library(BayesSpace);library(CellChat); #library(scCustomize);
library(berryFunctions);library(dataMaid)
library(cluster); library(factoextra); library(raveio);library(segmented)
#scCustomize and Signac does not work at the moment 30.9.24...


```

# Setting Global Variables
```{r, warning=FALSE,message=FALSE}
thedate <- strftime(Sys.Date(),"%d%m%y")
date=paste0('tikka',thedate) # Change this...# install.packages("ppcor") just in case the 'install' function here...
namedate = date#Change this (!)
# font_import() # This is important if you have not loaded them before
# loadfonts(device = "win") #Same applies here.
gc(); memory.limit(9999999999999);options(scipen = 999) #you do not want to see scientific numbering # You need to have rtools: https://cran.r-project.org/bin/windows/Rtools/rtools40.html
write('PATH="${RTOOLS40_HOME}\\usr\\bin;${PATH}"', file = "~/.Renviron", append = TRUE); 
# The mart/ensemble is often problematic (does not load or find the server). So, instead of loading this, try to save this...  or check host: 
# Sys.unsetenv("GITHUB_PAT"); mart <- useMart('ensembl', dataset = 'mmusculus_gene_ensembl', host = 'https://useast.ensembl.org') 
mart <- useEnsembl(biomart = "ensembl", dataset = 'mmusculus_gene_ensembl',mirror = "uswest") #?useEnsembl
# https://support.bioconductor.org/p/108324/
#Check also the place where to save:
ok='E:/uuttapuutta/'
setwd(dir=ok) #load(file = "hei.Rdata") #save.image('hei.Rdata')

```

# Importing Data and Metadata
```{r, warning=FALSE,message=FALSE}
#https://stackoverflow.com/questions/47295443/r-install-package-loaded-namespace
#1) Set the working directory and load the data:
#it is good to put one data 'type' as a folder:
# setwd(dir='D:/Data for Seurat Analysis/filtered_gene_bc_matrices/Data Filtered and Processed in Seurat/Corrected/E11/new2') #amap/lapimeno stands for 'as much as possible'
#Last spring (2021) data:

# load("C:/Users/patati/Desktop/TurkuOW/RWork/all.RData")

# #e 11... the below would better be a function:
# pbmc1.data <- Read10X_h5("E:/scRNAseq Data and Reference E9/E11-16 Open/E11.5_May21/mandible1_count/outs/filtered_feature_bc_matrix.h5")
# p11_1 <- CreateSeuratObject(counts = pbmc1.data, project = "E11.5_1", min.cells = 3, min.features = 200)
# pbmc2.data <- Read10X_h5("E:/scRNAseq Data and Reference E9/E11-16 Open/E11.5_May21/mandible2_count/outs/filtered_feature_bc_matrix.h5")
# p11_2 <- CreateSeuratObject(counts = pbmc2.data, project = "E11.5_2", min.cells = 3, min.features = 200)
# pbmc3.data <- Read10X_h5("E:/scRNAseq Data and Reference E9/E11-16 Open/E11.5_May21/mandible3_count/outs/filtered_feature_bc_matrix.h5")
# p11_3 <- CreateSeuratObject(counts = pbmc3.data, project = "E11.5_3", min.cells = 3, min.features = 200)
# pbmc4.data <- Read10X_h5("E:/scRNAseq Data and Reference E9/E11-16 Open/E11.5_May21/mandible4_count/outs/filtered_feature_bc_matrix.h5")
# p11_4 <- CreateSeuratObject(counts = pbmc4.data, project = "E11.5_4", min.cells = 3, min.features = 200)
# p11_5d <- Read10X_h5("E:/scRNAseq Data and Reference E9/E11-16 Open/E11_Oct21/1_count/outs/filtered_gene_bc_matrix.h5")
# p11_5 <- CreateSeuratObject(counts = p11_5d, project = "E11.5_5", min.cells = 3, min.features = 200)
# p11_6d <- Read10X_h5("E:/scRNAseq Data and Reference E9/E11-16 Open/E11_Oct21/2_count/outs/filtered_feature_bc_matrix.h5")
# p11_6 <- CreateSeuratObject(counts = p11_6d, project = "E11.5_6", min.cells = 3, min.features = 200)
# p11_7d <- Read10X_h5("E:/scRNAseq Data and Reference E9/E11-16 Open/E11_Oct21/3_count/outs/filtered_feature_bc_matrix.h5")
# p11_7 <- CreateSeuratObject(counts = p11_7d, project = "E11.5_7", min.cells = 3, min.features = 200)
# p11_8d <- Read10X_h5("E:/scRNAseq Data and Reference E9/E11-16 Open/E11_Oct21/4_count/outs/filtered_feature_bc_matrix.h5")
# p11_8 <- CreateSeuratObject(counts = p11_8d, project = "E11.5_8", min.cells = 3, min.features = 200)
# 
# pbmc1l.data <- Read10X_h5("E:/scRNAseq Data and Reference E9/E11-16 Open/E14.25_May21/1_1_count/outs/filtered_feature_bc_matrix.h5")
# p14_1 <- CreateSeuratObject(counts = pbmc1l.data, project = "E14.5_1", min.cells = 3, min.features = 200)
# pbmc2l.data <- Read10X_h5("E:/scRNAseq Data and Reference E9/E11-16 Open/E14.25_May21/1_2_count/outs/filtered_feature_bc_matrix.h5")
# p14_2 <- CreateSeuratObject(counts = pbmc2l.data, project = "E14.5_2", min.cells = 3, min.features = 200)
# pbmc3l.data <- Read10X_h5("E:/scRNAseq Data and Reference E9/E11-16 Open/E14.25_May21/1_count/outs/filtered_feature_bc_matrix.h5")
# p14_3 <- CreateSeuratObject(counts = pbmc3l.data, project = "E14.5_3", min.cells = 3, min.features = 200)
# pbmc4l.data <- Read10X_h5("E:/scRNAseq Data and Reference E9/E11-16 Open/E14.25_May21/2_count/outs/filtered_feature_bc_matrix.h5")
# p14_4 <- CreateSeuratObject(counts = pbmc4l.data, project = "E14.5_4", min.cells = 3, min.features = 200)
# p14_5d <- Read10X_h5("E:/scRNAseq Data and Reference E9/E11-16 Open/E14.25 and E16_Oct21/E14-1_Oct21/outs/filtered_feature_bc_matrix.h5")
# p14_5 <- CreateSeuratObject(counts = p14_5d, project = "E14.5_5", min.cells = 3, min.features = 200)
# p14_6d <- Read10X_h5("E:/scRNAseq Data and Reference E9/E11-16 Open/E14.25 and E16_Oct21/E14-2_Oct21/outs/filtered_feature_bc_matrix.h5")
# p14_6 <- CreateSeuratObject(counts = p14_6d, project = "E14.5_6", min.cells = 3, min.features = 200) #Maybe 20 was too little.., min.cells from 3 -> 10
# 
# p16_1d <- Read10X_h5("E:/scRNAseq Data and Reference E9/E11-16 Open/E14.25 and E16_Oct21/E16-1_Oct21/outs/filtered_feature_bc_matrix.h5")
# p16_1 <- CreateSeuratObject(counts = p16_1d, project = "E16.5_1", min.cells = 3, min.features = 200)
# p16_2d <- Read10X_h5("E:/scRNAseq Data and Reference E9/E11-16 Open/E14.25 and E16_Oct21/E16-2_Oct21/outs/filtered_feature_bc_matrix.h5")
# p16_2 <- CreateSeuratObject(counts = p16_2d, project = "E16.5_2", min.cells = 3, min.features = 200) #http://rcompanion.org/handbook/
# 
# #Merging Works like this: # https://satijalab.org/signac/articles/merging.html
# #total merge is not ok for filtering: data <- merge(p11_1, y = c(p11_2,p11_3,p11_4,p11_5,p11_6,p11_7,p11_8), project = "E11.5");gc(); #add.cell.ids = c("Later1", "Later2", "Later3", "Later4"),
# data1a <- merge(p11_1, y = c(p11_2,p11_3,p11_4), project = "E11.5a");gc(); #add.cell.ids = c("Later1", "Later2", "Later3", "Later4"), p11_5,p11_6,p11_7,p11_8
# # data1b <- merge(p11_5, y = c(p11_6,p11_7,p11_8), project = "E11.5b");gc();#test: p11_6 = merge(p11_6, y = c(p11_6), project = "E11.5_6");gc();p11_8 = merge(p11_8, y = c(p11_8,p11_8), project = "E11.5_8");gc();
# # data2a <- merge(p14_1, y = c(p14_2,p14_3,p14_4), project = "E14.25a")
# data2a <- merge(p14_1, y = c(p14_2,p14_3,p14_4,p14_5), project = "E14.25a")
# # data2b <- merge(p14_5, y = c(p14_6), project = "E14.25b") #
# data3 <- merge(p16_1, y = c(p16_2), project = "E16.5");gc();
# 
# gc();memory.limit(9999999999999); #testing: data2ax <- merge(p14_1, y = c(p14_2,p14_3,p14_4,p14_5,p14_6), project = "E14.25"); #data2ae=c(p14_1,p14_2,p14_3,p14_4,p14_5,p14_6)
# 
# #I rather put everything that leave away
# gc();
# rm(pbmc1.data,pbmc2.data,pbmc3.data,pbmc4.data,p11_5d,p11_6d,p11_7d,p11_8d,pbmc1l.data,pbmc2l.data,pbmc3l.data,pbmc4l.data,p11_5d,p11_6d,p11_7d,p11_8d,p14_5d,p14_6d,p16_1d,p16_2d)
# rm(p11_1,p11_2,p11_3,p11_4,p11_5,p11_6,p11_7,p11_8); #rm(vari, date1o, latex) #remove big sets...

# #In case you have ready data:
#If you have the data save as mentioned below: https://www.techcoil.com/blog/how-to-save-and-load-environment-objects-in-r/
# save.image(file='myEnvironment.RData')
# You can just:
# load('myEnvironment.RData')

#This is where you want to save the whole environment, unless you want to do the loading and processing every time, which is like 15min per stage, i.e. like 1h
# save.image(file='myEnvironment.RData')
# save.image("C:/Users/patati/Desktop/TurkuOW/RWork/all.RData")
load("C:/Users/patati/Desktop/TurkuOW/RWork/all.RData")

#Filtered
data1aa;data1aa[c('Sox2','Pitx2','Shh'),] 
data2aa;data2aa[c('Sox2','Pitx2','Shh'),] 
data3aa;data3aa[c('Sox2','Pitx2','Shh'),] 

#Integrated, but now (21024 the data1 not ok int as per):
Data1;Data1[c('Sox2','Pitx2','Shh'),] 
Data2;Data2[c('Sox2','Pitx2','Shh'),] 
Data3;Data3[c('Sox2','Pitx2','Shh'),] 


#Before you have anything analysed, biologists want to know how many cells express the gene 'X' of interest in one (not all) of their experiments: # length(WhichCells(data, slot = 'data', expression = Sox2 > 0 & Pitx2)) #This is exclusive, both have to occure.. so not work..
length(WhichCells(data1aa, slot = 'data', expression = Pitx2 > 0))#raw:868/424 length(WhichCells(data2a, slot = 'data', expression = Sox2 > 0))#raw:487/135 length(WhichCells(data3, slot = 'data', expression = Shh > 0))#raw:196/28 data # https://satijalab.org/seurat/articles/essential_commands.html




```

# The preporsessing function before the analysis
```{r, warning=FALSE,message=FALSE,fig.width=8.0}

Pre_anal_process=function(data,small,case='E11',mart) { #small to 'yes' if you have low number of cells in the sample
  #General variables in testing:# data=data1ae;# mart <- useMart('ensembl', dataset = 'mmusculus_gene_ensembl', host = 'https://useast.ensembl.org') #The below works if ensemble looks like:
  # data=data1a
  # small='no';case = "E11"
  DefaultAssay(data)='RNA' #Renaming cells in Seurat is not straightforward, e.g. if you do not want to show cell identities with their sample 'tag' at the end of sequence:
  ok1=colnames(data); ok11=substr(ok1, 1, 16); data=RenameCells(data, new.names = make.names(ok11, unique=TRUE) )
  #For Link AND HSP regression
  x=rownames(data@assays[["RNA"]]@meta.features)
  genes.meta<-getBM(mart = mart, attributes=c("ensembl_gene_id", "mgi_symbol", "go_id", 'gene_biotype'),filters="mgi_symbol",values=x)# getBM(attributes=c("ensembl_gene_id", "mgi_symbol", "go_id", 'gene_biotype'), filters="mgi_symbol",values=x,mart=ensembl) #%%useCache=F, note this..
  m <- match(rownames(data@assays[["RNA"]]@data), genes.meta$mgi_symbol)
  data@assays[["RNA"]]@meta.features<-cbind(data@assays[["RNA"]]@meta.features,genes.meta[m,])
  #Lnc filter ideas:
  lnc= c("lncRNA")
  RN_link_genes<-c(rownames(data[(data@assays[["RNA"]]@meta.features$gene_biotype %in% lnc),]))
  C<-GetAssayData(object = data, slot = "counts"); Link <- colSums(C[RN_link_genes,])/Matrix::colSums(C)*100
  data <- AddMetaData(data, Link, col.name = "percent.link") #Mes=c('Mpz') #
  #Mitos, ribos, largest gene:
  data[["percent.mt"]] <- PercentageFeatureSet(data, pattern = "^mt-")
  data[["percent_ribo"]] <- PercentageFeatureSet(data, pattern ='^Rpl|^Rps|^Mrpl|^Mrps')
  data$Percent.Largest.Gene=apply(data@assays$RNA@counts,2,function(x)(100*max(x))/sum(x)) #Filtering ribosomal genes: # https://nbisweden.github.io/excelerate-scRNAseq/session-qc/Quality_control.html # # https://nbisweden.github.io/workshop-scRNAseq/labs/compiled/scater/scater_01_qc.html
  #HSP:s
  HSP_genes<-genes.meta[genes.meta$go_id=="GO:0034605",]$mgi_symbol; hsp.genes <- rownames(data)[grep("^Hsp",rownames(data))]
  HSP_genes=c(hsp.genes,HSP_genes); C<-GetAssayData(object = data, slot = "counts"); Hsp <- colSums(C[HSP_genes,])/Matrix::colSums(C)*100 # data <- AddModuleScore(object = data,features = list(HSP_genes),name = 'HSP.score')
  data <- AddMetaData(data, Hsp, col.name = "percent.hsp") #Mes=c('Mpz') #
  #Blood score:
  hello=c("Tnnt1", "Tmsb4x", "Celf2", "Tpm2", "Tpm1", "Ebf1", "Abracl", "Ttn", "Pdgfa",
          "Mrln", "Ptprd", "Lrrn1", "Ybx3", "Zeb2", "Tubb2b", "S100a10", "Nexn", "Hes1", "Sh3glb1", "Foxp1", "Ntng1",
          "Ktn1", "Ccnd3", "Ppp3ca", "Cadm1", "Actr3", "Ccdc141", "Pgf", "Clcn5", "Zc3h15", "Tgfb2", "Fcer1g", "Tyrobp", "Arhgdib",
          "Coro1a", "Ptpn18", "Lst1", "Arpc1b", "Laptm5", "Cyba", "Itm2b", "Mef2c", "Cst3", "Lcp1", "Cd52", "B2m", "Sh3bgrl3","H19",
          "Tspo", "Sat1", "Apoe", "Arpc5", "Ctsc", "Tagln2", "Gpx1", "Rac2", "Clic1", "Fth1", "Ctsz", "Erp29", "Cotl1", "Cx3cr1", "Glipr2",
          "Ddx21", "Ncl", "Actb", "Gng11", "Mif", "Mdk", "Tubb5", "H2afz", "Hmgb2", "Tmsb10", "Fau", "Tpt1", "Eef1a1", "Hmgb1","Col4a1","Col4a2",
          "Fabp5","Pgk1","Arhgdib","Laptm5","Meis2","Gap43","Mef2c","Itm2a", "Prrx1","Plxnd1","Kdr","Aldoa", 'Des') # Ptma", "Des",
  #Let us take hb into account (28.6.21, tikka).. let us take them! (1.7.21)
  hb.genes <- rownames(data)[grep("^Hb",rownames(data))]; hello=c(hello,hb.genes); hello=unique(hello); #length(hello) 102
  #None of the blood genes should be epithelial ones:
  krts2=rownames(data)[grep("^Krt",rownames(data))]; krts22=rownames(data)[grep("^Wnt",rownames(data))]
  krts2=append(krts2, c("Epcam","Pitx2","Sox2","Foxi3","Sostdc1", "Dlx2", "Lef1", "p63", "Shh", "Noggin", "Sema3f",'Isl1', 'CD146', 'Nemo', 'Apc', 'Amel',
                        "Fgf8", "Hh", "Axin2", "FzD6", "Sp6", "Edar","Tgfb1","Lgr5", "Dkk3", "Igfp5", "Sfn","Odam", 'Stro-1', 'Edaradd', 'Il11ra',
                        "Fdcsp", "Slpi", "Odam", "Tuba1b", "Il1a", "Il1b", 'Pax9', 'Msx1', 'Msx2', 'Bmp2', 'Bmp4', 'Tbx3', 'Tbx2', 'Irf6', 'Irf6', 'Des',
                        "Bmi1", "ABCG2", "Oct3/4", "Oct3", "Oct4","Yap", "Gli1", "Lrig1", "Fgf10", "p21", "Dkk4", "Fgf9", "Fgf20", 'Edar', 'Dsp', 'Dspp',
                        'Ptma', 'Tpt1', 'Enam', 'Amelx','Mmp20', 'Amtn', 'Klk4', 'Dbi', 'Acta1','Actb','Pttg1', 'Atf3', 'Cldn10', 'Runx2',
                        'Ambn','Sfrp5', 'Tbx1', 'Dmp1', 'Notch1', 'Notch2', 'Ccl12', 'Pttg1', 'Atf3', 'Trfc', 'Ntrk2', 'Foxa1', 'Foxa2',
                        'Gjb6', 'Skap2', 'Lgr6', 'Lmo1', 'Gria2', 'Pcdh9', 'Kenh7', 'Lgals7', 'Pcp4l1', 'Npr3', 'Robo2', 'Kitl', 'Sic4a4', 'Cntn2', 'Unc5c', 'Rxfp1', 'Gjb2', 'Kcnj2',
                        'Meis1', 'Col12a1', 'Timp3', 'Prss23', 'Ednrb', 'Ddit4l', 'Gad1', 'Sp5', 'Proser2', 'Pkp1', 'Ppl', 'Nebi', 'Marveld2', 'Tagln',
                        'Acta2', 'Cpm', 'Dmrt2', 'Zcchc5', 'Rprm', 'Wisp1', 'Frnde1', 'Ntn1', 'Pax9', 'Foxc1',  'Hpca', 'Col14a1', 'Col9a1', 'Hpgd'))
  #In addition, exclude these from the blood, house and dissociation filtering and removals, as per Ana
  included=read.csv("E:/uuttapuutta/included.csv", header = FALSE);included=as.vector(included)$V1
  #Possibly add new genes, check the article 2022 Ye et al
  krts2=c(krts2,krts22,included);
  # krts2=c(krts2,krts22);
  hello=hello[!hello %in% unique(krts2)] # 
  C<-GetAssayData(object = data, slot = "counts"); hello=hello[hello %in% rownames(C)]; percent.blood <- colSums(C[hello,])/Matrix::colSums(C)*100
  data <- AddMetaData(data, percent.blood, col.name = "percent.blood") #Mes=c('Mpz') #
  
  #Krt score
  jello=c('Krt5','Krt14','Krt17','Krt18'); C<-GetAssayData(object = data, slot = "counts"); jello=jello[jello %in% rownames(C)]; percent.KRT <- colSums(C[jello,])/Matrix::colSums(C)*100
  data <- AddMetaData(data, percent.KRT, col.name = "percent.KRT") #
  # VlnPlot(data , features = 'percent.KRT')+ylim(0,0.5)
  # data[c('Pitx2','Sox2'),]
  
  #Met score; https://en.wikipedia.org/wiki/Mesenchymal%E2%80%93epithelial_transition
  # E-cadherin/Cdh1, Cldns −3, −4, −7, −11, Occludin (Ocln), Epithelial cell adhesion molecule (Epcam), and Crumbs homolog 3 (Crb3), were all upregulated before Nanog, 
  #a key transcription factor in maintaining pluripotency, was turned on. Additionally, mesenchymal-associated genes such as Snail, Slug, Zeb −1, −2, 
  # and N-cadherin were downregulated within the first 5 days post-OKSM induction.[16] Addition of exogenous TGF-β1, which blocks MET, decreased iPS reprogramming efficiency significantly# Sox2, Epcam 
  jello=c('Cdh1','Crb3','Cldn3','Cldn4','Cldn7','Cldn11','Ocln','Nanog','Epcam','Klf4','Sox2');
  jello2=c('Tgfb1', 'Snail1', 'Snail2','Zeb1','Zeb2','Cdh2','Vim')
  C<-GetAssayData(object = data, slot = "counts");
  jello=jello[jello %in% rownames(C)]; jello2=jello2[jello2 %in% rownames(C)];
  MET.Score <- colSums(C[jello,])/Matrix::colSums(C)*3 - (colSums(C[jello2,])/Matrix::colSums(C))*0.5
  data <- AddMetaData(data, MET.Score, col.name = "MET.Score")
  # VlnPlot(data , features = 'MET.Score')#+ylim(0,20)
  # data[c('Pitx2','Sox2'),]
  
  #Emt score
  # hello=c('Krt5','Krt14','Krt17','Krt18'); C<-GetAssayData(object = data, slot = "counts"); 
  # hello=hello[hello %in% rownames(C)]; percent.KRT <- colSums(C[hello,])/Matrix::colSums(C)*100
  # data <- AddMetaData(data, percent.KRT, col.name = "percent.KRT")
  
  #Housekeeping gene#Bone, hema, and stem.. + the basics
  house=c("Col3a1", "Eef1b2", "Rpl37a", "Ptma", "Gas5", "H3f3a",  "Man1b1", "Set",  "Abl1", "Stam2",  "Hnrnpa3",      "Zfp106", "Serf2",  "B2m",  "Snrnp200",     "Csnk2a1",      "Gnas", "Sec62",  "Tpm3", "S100a4", "Atp5f1", "H2afz",  "Aco1", "Ybx1", "Ppih", "Sfpq", "Pum1", "Zdhhc18",      "Stmn1",  "Rer1",  "Srp72",  "Rplp0",  "Eif2b1", "Ubc",  "Chchd2", "Gusb", "Actb", "Flt1", "Hmgb1",  "Ptn",  "Hnrnpa2b1",    "Gadd45a",      "Mrpl19", "Snrpg",  "Rpl32", "Gapdh",  "Cdkn1b", "Ipo8", "Strn4",  "Psmc4",  "Rps16",  "Lsm14a", "Pop4", "Rpl13a", "Rpl18",  "Ldha", "Rps17",  "Ints4",  "1110004F10Rik","Gtf3c1", "Vps36",  "Calr", "Kars", "Cox4i1", "Hmbs", "Ddx6", "Edc3", "Rpl4", "Ppib", "Morf4l1",      "Oaz1", "Cactin", "Polr3b", "Tbk1", "Usp15",
          "Naca",  "Pes1", "Ppia", "Sec61g", "Npm1", "Rack1",  "Ubb",  "Polr2a", "Cltc", "Nme2", "Casc3",  "Eif1", "Rpl27",  "Ddx5", "Rpl38", "H3f3b",  "Actg1",  "Brms1l", "Eif5", "Hnrnpk", "Sdha", "Cox7c",  "Btf3", "Dnajc9", "Sec24c", "Supt16", "Elf1", "Rpl37",  "Rpl30",  "Cox6c",
          "Pabpc1", "Ywhaz",  "Cpsf1",  "Lgals1", "Ddx17",  "Cyp2d26",      "Pcbp2",  "Ubn1", "1810013L24Rik","Tfrc", "Snx4", "Hmgn1",  "Tbp",  "Atp6v0c",      "Hmga1", "Cdkn1a", "Rps18",  "Abcf1",  "Hsp90ab1",     "Taf4b",  "Iws1", "Eif1a",  "Fech", "Neat1",  "Ganab",  "Ddb1", "Mpp1", "Nono", "Pgk1", "Lgals12")
  house=house[!house %in% unique(included)];
  C<-GetAssayData(object = data, slot = "counts");house=house[house %in% rownames(C)]
  percent.house <- colSums(C[c(house),])/Matrix::colSums(C)*100
  data <- AddMetaData(data, percent.house, col.name = "percent.house") #Mes=c('Mpz') #
  ### calculate the percentage of dissociation genes
  dissociation_genes <- c("Actg1","Ankrd1","Arid5a","Atf3","Atf4","Bag3","Bhlhe40","Brd2","Btg1","Btg2","Ccnl1","Ccrn4l","Cebpb","Cebpd","Cebpg","Csrnp1","Cxcl1",
                          "Cyr61","Dcn","Ddx3x","Ddx5","Des","Dnaja1","Dnajb1","Dnajb4","Dusp1","Dusp8","Egr1","Egr2","Eif1","Eif5","Erf","Errfi1","Fam132b",
                          "Fos","Fosb","Fosl2","Gadd45a","Gadd45g","Gcc1","Gem","H3f3b","Hipk3","Hsp90aa1","Hsp90ab1","Hspa1a","Hspa1b","Hspa5","Hspa8",
                          "Hspb1","Hspe1","Hsph1","Id3","Idi1","Ier2","Ier3","Ier5","Ifrd1","Il6","Irf1","Irf8","Itpkc","Jun","Junb","Jund","Kcne4","Klf2",
                          "Klf4","Klf6","Klf9","Litaf","Lmna","Maff","Mafk","Mcl1","Midn","Mir22hg","Mt1","Mt2","Myadm","Myc","Myd88","Nckap5l","Ncoa7",
                          "Nfkbia","Nfkbiz","Nop58","Nppc","Nr4a1","Odc1","Osgin1","Oxnad1","Pcf11","Pde4b","Per1","Phlda1","Pnp","Pnrc1","Ppp1cc","Ppp1r15a",
                          "Pxdc1","Rap1b","Rassf1","Rhob","Rhoh","Ripk1","Sat1","Sbno2","Sdc4","Serpine1","Skil","Slc10a6","Slc38a2","Slc41a1","Socs3","Sqstm1",
                          "Srf","Srsf5","Srsf7","Stat3","Tagln2","Tiparp","Tnfaip3","Tnfaip6","Tpm3","Tppp3","Tra2a","Tra2b","Trib1","Tubb4b","Tubb6","Ubc",
                          "Usp2","Wac","Zc3h12a","Zfand5","Zfp36","Zfp36l1","Zfp36l2","Zyx")
  dissociation_genes=dissociation_genes[!dissociation_genes %in% unique(included)];
  C<-GetAssayData(object = data, slot = "counts"); 
  dissa=unique(dissociation_genes); dissa=rownames(C[rownames(C) %in% dissa,]); 
  disso <- colSums(C[dissa,])/Matrix::colSums(C)*100
  data <- AddMetaData(data, disso, col.name = "percent_disso") #Mes=c('Mpz') #
  
  #Unrepresentative genes away:
  data$log10GenesPerUMI <- log10(data$nFeature_RNA) / log10(data$nCount_RNA); #VlnPlot(data,features="log10GenesPerUMI")+  ggtitle("")
  #Limits for molecule and gene detection, mitos, ribos, blood and HSPs:
  nmin=round_any(quantile(data$nCount_RNA, p=0.05),100,f = ceiling)# 
  nmax=round_any(quantile(data$nCount_RNA, p=0.99),100,f = ceiling)
  a=quantile(data$nFeature_RNA[ data$nFeature_RNA<quantile(data$nFeature_RNA,0.25) ], p=0.5); b=sd((data$nFeature_RNA[ data$nFeature_RNA<quantile(data$nFeature_RNA,0.25) & !data$nFeature_RNA==0 ])) #179.3488
  min=round(a+b,0);min2=ceiling(2/3*round(a+b,0))
  a=quantile(data$nFeature_RNA[ data$nFeature_RNA>quantile(data$nFeature_RNA,0.95) ], p=0.5); b=sd((data$nFeature_RNA[ data$nFeature_RNA>quantile(data$nFeature_RNA,0.95) ])) #179.3488
  max=round(a+b,0);max2=ceiling(5/3*round(a+b,0)) #4552 ->4600,
  #pm=round(quantile(data$percent.mt, p=0.75)+2^sd(log2(data$percent.mt[!data$percent.mt==0]))) #sqrt(mean(data$percent.mt[!data$percent.mt==0])); a little bit too high compared to 2.7... and log2 ->ok
  # logs are due to high variation, 2*sd(data$percent.mt[!data$percent.mt==0])~15, which is too much to add to mean, whereas log2 values smoothen the results..
  # VlnPlot(data, features="percent.mt",  group.by='orig.ident')+  ggtitle(""); 
  # median(data$percent.mt)+2*sd(data$percent.mt) close or quantile(data$percent.mt,0.75)+sd(data$percent.mt) 
  pme=round(quantile(data$percent.mt[!data$percent.mt==0], p=0.75)+sqrt(mean(data$percent.mt[!data$percent.mt==0]))) #https://www.sciencedirect.com/topics/mathematics/poisson-distribution
  # > median(data$percent.mt[!data$percent.mt==0])
  # [1] 5.058491 (too low)
  # > mean(data$percent.mt[!data$percent.mt==0])
  # [1] 8.764324 (too low too)
  # The 99-percent confidence interval is calculated as: λ ±2.58*sqrt(λ/n), not sure if needed here...
  # pme=round(mean(data$percent.mt[!data$percent.mt==0])+2.58*sqrt(mean(data$percent.mt[!data$percent.mt==0])/length(data$percent.mt[!data$percent.mt==0])),4)
  #pm2=round(quantile(data$percent.mt, p=0.9)+2^sd(log2(data$percent.mt[!data$percent.mt==0]))) #why log2 and power of 2? ... it was probably because the values were 'high'
  pme2=round(quantile(data$percent.mt[!data$percent.mt==0], p=0.9)+sqrt(mean(data$percent.mt[!data$percent.mt==0])))
  #lg=round(quantile(data$Percent.Largest.Gene, p=0.98)+2^sd(log2(data$Percent.Largest.Gene))) #8%; quantile(data$Percent.Largest.Gene, p=0.98)+2*sd(data$Percent.Largest.Gene) is higher...  yes..
  lge=round(quantile(data$Percent.Largest.Gene[!data$Percent.Largest.Gene==0],p=0.98)+sqrt(mean(data$Percent.Largest.Gene[!data$Percent.Largest.Gene==0])),1)
  #lg2=round(quantile(data$Percent.Largest.Gene, p=0.99)+2^sd(log2(data$Percent.Largest.Gene))) #8%
  lge2=round(quantile(data$Percent.Largest.Gene[!data$Percent.Largest.Gene==0],p=0.99)+sqrt(mean(data$Percent.Largest.Gene[!data$Percent.Largest.Gene==0])),1)
  rply=round(quantile(data$percent_ribo, p=0.98)); #rpsy=round(quantile(data$percent.Rps, p=0.99))
  B=round(quantile(data[[]][,'percent.blood'],0.92),3); #VlnPlot(data, features="percent.blood",  group.by='orig.ident')+  ggtitle("")+ylim(2,20)  #split.by = "orig.ident",
  # hsp1=round(quantile(data$percent.hsp, p=0.01),1);
  hsp2=round(quantile(data$percent.hsp, p=0.99),1) #VlnPlot(data, features="HSP.score1",  group.by='orig.ident')+  ggtitle("")+ylim(-2,10)  #split.by = "orig.ident",
  huussi=round(quantile(data$percent.house, p=0.99),1) #VlnPlot(data, features="House1",  group.by='orig.ident')+  ggtitle("")+ylim(0,100)  #split.by = "orig.ident",
  linkki=round(quantile(data$percent.link, p=0.98),1)
  dissen=round(mean(data$percent_disso[!data$percent_disso==0])+2*sd(data$percent_disso[!data$percent_disso==0]),3)  #normally distributed, so mean+2sd works here...
  #Here was a mistake..dissen2=round(quantile(data$nFeature_RNA, p=0.98),1)
  # VlnPlot(data,features="percent_disso")+  ggtitle("") #& ylim(0,10);
  # https://www.nature.com/articles/s41467-021-27035-8#code-availability # https://github.com/egarren/scTfh# https://constantamateur.github.io/2020-10-24-scBatch2/# https://hbctraining.github.io/scRNA-seq/lessons/04_SC_quality_control.html
  # Newest article 2022 about Ye et al....# > data #An object of class Seurat  #18881    features across 32700    samples within 1 assay #Active assay: RNA (18881 features, 0 variable features)
  # data[c('Pitx2','Sox2'),] #Vielä on
  
  #The below will be needed for presentation purposes:
  # VlnPlot(data, features = c("nFeature_RNA", "nCount_RNA", "percent.mt",'Percent.Largest.Gene',"log10GenesPerUMI",
                             # "percent_ribo", "percent.blood","percent.link", 'percent.house',"percent_disso" ), ncol = 2,group.by='orig.ident')+  ggtitle("") #https://github.com/egarren/scTfh/blob/main/code/01_gex.R
  # data=data1ok;
  # min;max;nmin;nmax;0.78;pme;lge;dissen;linkki;rply;B;hsp2;huussi
  
  # VlnPlot(data, features = c("percent.hsp"), ncol = 1) 
  
  if (small!='yes') {data= subset(data, nFeature_RNA>min & nFeature_RNA < max & nCount_RNA>nmin & nCount_RNA<nmax & #check this..
                                    log10GenesPerUMI > 0.78 & percent.mt < pme  & Percent.Largest.Gene < lge & percent_disso < dissen & #& percent.mt >  -Inf
                                    percent.link < linkki & percent_ribo < rply & #percent_ribo > rpl & # percent.Rps < rpsy & & percent.Rps > rps & #percent.hb <hb & S.Score < S & G2M.Score< G & #hb is fused to 'percent.blood', which has other gens also
                                    percent.blood < B & percent.hsp < hsp2 & percent.house<huussi)} else if (small=='yes')  #& percent.hsp > hsp1)# percent.hsp > hsp1  & b=5.97%) # check the scores...  perhaps excessive
                        
  {data= subset(data, nFeature_RNA>min2 & nFeature_RNA < max2  & percent.mt < pme2  & Percent.Largest.Gene < lge2)} #
  # data[c('Pitx2','Sox2'),]

# VlnPlot(data,features="percent_disso",group.by='orig.ident')+  ggtitle("") #& ylim(0,10);

  # data_alt=data
  
  # Filter MALAT1, #tää voi lähteä sellasenaan.. ja
  data <- data[!grepl("Malat1", rownames(data)), ]; data <- data[!grepl("Gm42418", rownames(data)), ];  data <- data[!grepl("AY036118", rownames(data)), ]
  # Filter Gm42418 and AY036118, https://github.com/egarren/scTfh/blob/main/code/01_gex.R# #TCR and Ig identification and filtering
  ig_list <- c("IG_C_gene", "IG_C_pseudogene", "IG_D_gene", "IG_D_pseudogene", "IG_J_gene", "IG_LV_gene","IG_pseudogene", "IG_V_gene", "IG_V_pseudogene")
  tr_list <-c("TR_V_gene", "TR_V_pseudogene", "TR_D_gene", "TR_J_gene", "TR_J_pseudogene", "TR_C_gene")
  data <- subset(data, features=rownames(data[!(data@assays[["RNA"]]@meta.features$gene_biotype %in% ig_list),])) #2 genes
  data <- subset(data, features=rownames(data[!(data@assays[["RNA"]]@meta.features$gene_biotype %in% tr_list),])) #1 genes# sum(krts2 %in% rownames(data[is.na(data@assays[["RNA"]]@meta.features$mgi_symbol),])) #ok, i.e. 0, delete below:
  # data[c('Pitx2','Sox2'),] #ok
  
  data <- subset(data, features=rownames(data[!(rownames(data) %in% hello),])) #https://adv-r.hadley.nz/subsetting.html#Mitot away:
  # data[c('Pitx2','Sox2'),] #ok
  data <- data[!grepl("^mt-", rownames(data)), ] #HSP genes away:
  data <- subset(data, features=rownames(data[!(rownames(data) %in% HSP_genes),])) #also zero to epit #75 genes# #%%Ribot away
  data <- data[!grepl("^Rp[sl]", rownames(data)), ]; data <- data[!grepl("Mrp[sl]", rownames(data)), ] #pattern ='^Rpl|^Rps|^Mrpl|^Mrps')#%%House away!
  data <- subset(data, features=rownames(data[!(rownames(data) %in% house),])) #also zero to epit, sum(house %in% krts2n)#  #Cell cycle.. now looks better... # S=round(quantile(data[[]][,'S.Score'],0.999),3); G=round(quantile(data[[]][,'S.Score'],0.999),3) #on vielä
  data = CellCycleScoring(data, s.features = str_to_title(cc.genes.updated.2019$s.genes), g2m.features = str_to_title(cc.genes.updated.2019$g2m.genes), set.ident = TRUE) #n = 21
  # data[c('Pitx2','Sox2'),] #ok
  # case='E14'
  #Calculating droplets requires a function:
  ax=function(data,urgency,case) {
    #https://www.geeksforgeeks.org/convert-first-letter-of-every-word-to-uppercase-in-r-programming-str_to_title-function/
    # https://stackoverflow.com/questions/1169388/finding-all-positions-for-multiple-elements-in-a-vector
    # https://academic.oup.com/biomedgerontology/article/69/12/1437/592768
    lista2<- SplitObject(data, split.by = "orig.ident"); #pituus2=c() #DataList #auxiliary for the doublets
    #https://raw.githubusercontent.com/NBISweden/workshop-scRNAseq/master/labs/compiled/seurat/seurat_01_qc.Rmd#s, https://raw.githubusercontent.com/NBISweden/workshop-scRNAseq/master/labs/compiled/seurat/seurat_01_qc.Rmd
    c= c();nw7=c();nameesa=c()
    for(i in 1:length(lista2)) { #you need to have list_pa2 here (not lista2)
      data.filt = FindVariableFeatures(lista2[[i]], verbose = F);
      if (case=='E11') {vtr = c('percent_ribo','percent.blood',"G2M.Score","S.Score",'percent.house','percent.mt','percent.link','percent.hsp')} else vtr = c('percent.mt',"G2M.Score","S.Score",'percent.link','percent.hsp','percent.house')
      data.filt = ScaleData(data.filt, vars.to.regress = vtr,verbose = F);
      data.filt = RunPCA(data.filt, verbose = F, npcs = 22);
      data.filt = RunUMAP(data.filt, dims = 1:15, verbose = F, n.neighbors = 23); # define the expected number of doublet cells:
      # https://github.com/satijalab/seurat/issues/4312
      nExp <- round(ncol(data.filt) * 0.05);  # expect 5/4% doublets, or more than smaller samples, https://raw.githubusercontent.com/NBISweden/workshop-scRNAseq/master/labs/compiled/seurat/seurat_01_qc.Rmd
      data.filt <- NormalizeData(data.filt);
      data.filt <- doubletFinder_v3(data.filt, pN = 0.25, pK = 0.09, nExp = nExp, PCs = 1:15); # name of the DF prediction can change, so extract the correct column name.
      DF.name = colnames(data.filt@meta.data)[grepl("DF.classification", colnames(data.filt@meta.data))];
      c=colnames(data.filt[, data.filt@meta.data[, DF.name] == "Singlet"]); nw7<-append(nw7,list(c))}
    nameesa=unlist(nw7);james=c()
    james=c(nameesa); james=unique(james); #
    data=data[,james] #from https://rpubs.com/Mentors_Ubiqum/capture_output
    return(data)}
  if (small!='yes') {data=ax(data,urgency,case)};#data[c('Pitx2','Sox2'),]
  return(data)}
```


# Filterings

```{r, warning=FALSE,message=FALSE,fig.width=8.0}

#E11 filtering
data1a;data1a[c('Sox2','Pitx2','Shh'),] 
DefaultAssay(data1a)='RNA';small='no'; gc(); memory.limit(9999999999999);
data1aa=Pre_anal_process(data1a,small,case='E11',mart); 
data1aa;data1aa[c('Sox2','Pitx2','Shh'),]  #did have pitx2 and sox2 in the end; ok
name=paste('data_e11_big_filter',namedate,'.rds');saveRDS(data1aa, file = name)# data1a <- readRDS(file = ".../Corrected/E11/to/data_e11_big_filter_Tikka_17.5.23.rds")

data2a;data2a[c('Sox2','Pitx2','Shh'),] 
DefaultAssay(data2a)='RNA';small='no'; gc(); memory.limit(9999999999999);
data2aa = Pre_anal_process(data2a,small,case='E11',mart);data2a; data2a[c('Sox2','Pitx2','Shh'),]
data2aa;data2aa[c('Sox2','Pitx2'),]  #did have pitx2 and sox2 in the end
name=paste('data_e14_big_filter_ok1',namedate,'.rds');saveRDS(data2aa , file = name) #data2a <- readRDS(file = "data_e14_big_filter_ok1 Tikka 5.7.23 .rds")
# DefaultAssay(data2b)='RNA'; small='no'; gc(); memory.limit(9999999999999); #note that this dataset is not small...
# data2b=Pre_anal_process(data2b,small,case='E11',mart); data2b; data2b[c('Sox2','Pitx2'),] # https://github.com/satijalab/seurat/issues/4803, https://github.com/satijalab/seurat/issues/5563

#E16 filtering, Before filter

data3;data3[c('Sox2','Pitx2','Shh'),] 
DefaultAssay(data3)='RNA';small='no'; gc(); memory.limit(9999999999999);
data3aa = Pre_anal_process(data3,small,case='E16',mart);data3aa; data3aa[c('Sox2','Pitx2','Shh'),]#
name=paste('data_e16_big_filter_ok1',namedate,'.rds');saveRDS(data3 , file = name) 



#For this you need to have Datalist, data, the name for saving, and mc for number of cell in minimum sample (if less than 100, and if above then 100)
# DefaultAssay(data1a) <- "RNA";DataList1 <- SplitObject(data1a, split.by = "orig.ident") #DataList is made from the filtered data, but check manually if any of the sets are less than 80 cells
# DefaultAssay(data1b) <- "RNA";DataList2 <- SplitObject(data1b, split.by = "orig.ident")
# DefaultAssay(data2a) <- "RNA";DataList2 <- SplitObject(data2a, split.by = "orig.ident") #DataList is made from the filtered data, but check manually if any of the sets are less than 80 cells
# DefaultAssay(data2b) <- "RNA";DataList2 <- SplitObject(data2b, split.by = "orig.ident")
# DefaultAssay(data22) <- "RNA";DataList1 <- SplitObject(data22, split.by = "orig.ident") #DataList is made from the filtered data, but check manually if any of the sets are less than 80 cells
# DefaultAssay(data3)  <- "RNA";DataList3 <- SplitObject(data3, split.by = "orig.ident")



#This works for E11 and E14:
# mc=100#min cell number, sample 1 and 2
# date1=Transform1(DataList1,mc,case='E14') #Check your case.. #Needs to be regressed at least: "G2M.Score","S.Score",percent.mt,percent.link
#this is now second version of the total merge... with transfrom2 and filter to two experiments otherwise differently
# date1[[1]]; date1[[2]]; date1[[3]]; date1o=date1[[1]];date1o; date1o[c('Sox2','Pitx2'),]
```


# Computational Analysis Functions
```{r, warning=FALSE,message=FALSE,fig.width=8.0}

# The preprosessing and initial scRNAseq analysis (i.e. the umaps) functions

# This is a gene & cell filtering function needed before analyses# The input of this function is your merged seurat object and name for saving it and output the filtered (and saved) seurat data object (+image) ready for normalization: Ok denotes the good sample numbers
# This excludes cells expressing an unwanted gene with a wanted percentile# The smaller the percentile, the more the unwanted gene you have excluded and more included the wanted ones
Ex_nam=function(pb22,gene,percentile,assay) {
  DefaultAssay(pb22) <- assay
  x=GetAssayData(subset(x = pb22, features = c(gene)));
  x=as.double(x);#names(x)=håj
  x2 <- as.numeric(x); if (assay=='RNA') {print(table(x2))}
  print(c(min(x2), max(x2), median(x2), mean(x2),quantile(x2,percentile)))
  hist(x2, xlim=c(min(x2),quantile(x2,0.99)),breaks=200);
  lep=quantile(x2,percentile); lep
  x2=x[x <= lep]; houm=names(x2);toInclude <- houm;
  print(c(sum(colnames(pb22) %in% toInclude)))
  pb22a <- pb22[,colnames(pb22) %in% toInclude]
  houm2=colnames(pb22a)
  DefaultAssay(pb22) <- "RNA"
  return(houm2)}

In_nam=function(mes1,gene,percentile,assay) {
  DefaultAssay(mes1) <- assay; #gene='Msx1'; percentile=0.5;assay='RNA'; 
  x=GetAssayData(subset(x = mes1, features = c(gene)));
  x=x[, colSums(x !=  min(x) ) >  min(x) ]
  x2 <- as.numeric(x); if (assay=='RNA') {print(table(x2))} else if (assay=='SCT') {print(table(x2))}
  print(c(min(x2), max(x2), median(x2), mean(x2),quantile(x2,percentile)))
  hist(x2, xlim=c(min(x2),quantile(x2,0.9)),breaks=200);
  lep=quantile(x2,percentile); lep
  x2=x[x >= lep]; houm=names(x2);toInclude <- houm;
  print(c(sum(colnames(mes1) %in% toInclude)))
  mes1a <- mes1[,colnames(mes1) %in% toInclude]
  houm2=colnames(mes1a)
  return(houm2)}

#Transform at least work with bigger gene amount; #https://satijalab.org/seurat/reference/integratedata, https://satijalab.org/seurat/reference/findintegrationanchors
##Tested with small number of genes, since this method does not have PC amount, and it did go through.. (if oke is loke and)
Transform1 <- function(DataList,mc,case='E11') {
  #https://github.com/satijalab/seurat/issues/1528#scale should be ok: https://github.com/satijalab/seurat/issues/1708
  DataList=DataList1
  hap=c(); for(i in 1:length(DataList)) {pata=DataList[[i]]; tap1a=round_any(dim(pata)[1]*0.33, 100,f = ceiling); hap=append(hap,tap1a)
  pb1=NormalizeData(pata, normalization.method = "LogNormalize", scale.factor = 10000) #scale should be ok: https://github.com/satijalab/seurat/issues/1708
  teg=c(5,20,50,100,500,1000,2000,3000,4000,5000,6000,8000,10000,13000); na<-c()
  for(i in 1:12) {ob1=FindVariableFeatures(object = pb1, selection.method = "mvp",num.bin=teg[i]); var1=length(VariableFeatures(object = ob1)); var1; na<-append(na,var1)}} 
  tap1=round_any(median(na)*1.1, 10,f = ceiling); tp1=round_any((tap1*3+median(hap)*2)/5, 100,f = ceiling)  
  # tp1
  # https://github.com/satijalab/seurat/issues/3061#https://satijalab.org/seurat/articles/integration_rpca.html https://github.com/satijalab/seurat/issues/3061 ...
  if (case=='E14') {vtr = c('percent_ribo','percent.blood',"G2M.Score","S.Score",'percent.house','percent.mt','percent.link','percent.hsp')} else {vtr = c("G2M.Score","S.Score",'percent.mt','percent.link','percent.house')} #'percent.mt',"G2M.Score","S.Score",'percent.link','percent.hsp','percent.house'
  DataList <- lapply(X = DataList, FUN = SCTransform,vst.flavor="v2",vars.to.regress = vtr, variable.features.n = 8000,method = "glmGamPoi")#this is about 5-10min (second slowests)
  
  # for (i in 1:4) {DataList[[i]] <- SCTransform(DataList[[i]], vst.flavor="v2",
  # vars.to.regress = vtr, residual.features = 
  # unique(c(VariableFeatures(DataList[[i]]),'Sox2','Shh','Pitx2')),method = "glmGamPoi")}
  
  # if (case=='E11') {namesa=c(VariableFeatures(DataList[[1]]),'Sox2','Shh','Pitx2')
  # DataList <- lapply(X = DataList, FUN = SCTransform,vst.flavor="v2",vars.to.regress = vtr, residual.features = namesa,method = "glmGamPoi")}
  
  features <- SelectIntegrationFeatures(object.list = DataList, nfeatures = tp1); 
  # features=unique(c(features,'Sox2','Shh','Pitx2')) # you need to add your genes of interest here
  sum(features=='Sox2'); sum(features=='Shh')
  
  DataList <- PrepSCTIntegration(object.list = DataList, anchor.features = features);gc();#mc=100
  anchors <- FindIntegrationAnchors(object.list = DataList,normalization.method = "SCT",anchor.features = features);gc(); #This is the slowest, 10-30min depending on samples and method (or longer!)
  combined <- IntegrateData(anchorset = anchors, normalization.method = "SCT",k.weight = mc) #this lasts around 3-5min (thirds slowest); even though it is fast it could crash if mc is high
  datajei=combined;
  return(c(datajei,tp1,tap1))}#'percent.hsp',

Transform2 <- function(DataList,mc) { #This does not have any variables to regress, which is probably not ok...
  #https://github.com/satijalab/seurat/issues/1528#scale should be ok: https://github.com/satijalab/seurat/issues/1708
  
  DataList=DataList1
  hap=c(); for(i in 1:length(DataList)) {pata=DataList[[i]]; tap1a=round_any(dim(pata)[1]*0.33, 100,f = ceiling); hap=append(hap,tap1a)
  pb1=NormalizeData(pata, normalization.method = "LogNormalize", scale.factor = 10000) #scale should be ok: https://github.com/satijalab/seurat/issues/1708
  teg=c(5,20,50,100,500,1000,2000,3000,4000,5000,6000,8000,10000,13000); na<-c()
  for(i in 1:12) {ob1=FindVariableFeatures(object = pb1, selection.method = "mvp",num.bin=teg[i]); var1=length(VariableFeatures(object = ob1)); var1; na<-append(na,var1)}} 
  tap1=round_any(median(na)*1.1, 10,f = ceiling); tp1=round_any((tap1*3+median(hap)*2)/5, 100,f = ceiling)  
  # https://github.com/satijalab/seurat/issues/3061#https://satijalab.org/seurat/articles/integration_rpca.html https://github.com/satijalab/seurat/issues/3061 ...
  DataList <- lapply(X = DataList, FUN = SCTransform,vst.flavor="v2", variable.features.n = tp1,method = "glmGamPoi");  #this is about 5-10min (second slowests)
  features <- SelectIntegrationFeatures(object.list = DataList, nfeatures = tp1); 
  DataList <- PrepSCTIntegration(object.list = DataList, anchor.features = features);gc();#mc=100
  anchors <- FindIntegrationAnchors(object.list = DataList,normalization.method = "SCT",anchor.features = features);gc(); 
  #This is the slowest, 10-30min depending on samples and method (or longer!)
  combined <- IntegrateData(anchorset = anchors, normalization.method = "SCT",k.weight = mc) #this lasts around 3-5min (thirds slowest); even though it is fast it could crash if mc is high
  datajei=combined;
  return(c(datajei,tp1,tap1))}

Merge_Norm = function(vari,regout='mito',PC='ok',res='ok') { #regout: (mito, phase, both), PC&res (if ok then default) else insert number
  # regout='mito';PC='ok';res='ok'
  tap1a=round_any(dim(vari)[1]*0.33, 100,f = ceiling)
  pb1=NormalizeData(vari, normalization.method = "LogNormalize", scale.factor = 10000) #scale should be ok: https://github.com/satijalab/seurat/issues/1708
  ob1=FindVariableFeatures(object = pb1, selection.method = "mvp",num.bin=20); var1=length(VariableFeatures(object = ob1)); #var1 times 1.2 or 1.1 etc., num.bin=20 on std 3000 max
  tap1=round_any(var1*1.1, 10,f = ceiling); tp1=round_any((tap1*3+tap1a*2)/5, 100,f = ceiling)
  if (regout=='mito') {vtr = c('percent.mt')} else if (regout=='phase') {vtr = c("G2M.Score","S.Score")} else if (regout=='both') {vtr = c('percent.mt',"G2M.Score","S.Score")}
  vari[["percent.mt"]] <- PercentageFeatureSet(vari, pattern = "^mt-") #the mitos have already been filtered..VlnPlot(vari,features="percent.mt")+  ggtitle("")
  vari = CellCycleScoring(vari, s.features = str_to_title(cc.genes.updated.2019$s.genes), g2m.features = str_to_title(cc.genes.updated.2019$g2m.genes), set.ident = TRUE) #n = 21
  vari <- SCTransform(vari,variable.features.n = tp1,method = "glmGamPoi",vst.flavor="v2",vars.to.regress = vtr) #vars.to.regress = c('percent.mt',"G2M.Score","S.Score"
  vari <- vari[!grepl("^mt-", rownames(vari)), ]
  DefaultAssay(vari) <- "SCT"
  vari <- RunPCA(vari, features = VariableFeatures(object = vari))
  ElbowPlot(object = vari, ndims = 50); pct <- vari[["pca"]]@stdev / sum(vari[["pca"]]@stdev) * 100; cumu <- cumsum(pct)
  co1 <- which(cumu > 90 & pct < 5)[1];co2 <- sort(which((pct[1:length(pct) - 1] - pct[2:length(pct)]) > 0.1), decreasing = T)[1] + 1
  pcs <- min(co1, co2);co1;co2;pcs
   data.frame(pct = pct,cumu = cumu,rank = 1:length(pct)); plot_df <-ggplot(plot_df, aes(cumu, pct, label = rank, color = rank > pcs)) + geom_text() + geom_vline(xintercept = 99, color = "grey") + geom_hline(yintercept = min(pct[pct > 1]), color = "grey") + theme_bw()
  print(plot_df); png("PCs in elbow.png", width = 9000, height = 9000,pointsize = 16, res=1200);print(plot_df);dev.off() 
  if (PC=='ok') {z=pcs} else if (PC!='ok') {z=PC}; if (res=='ok') {res=0.5} else if (res!='ok') {res=res};
  vari <- FindNeighbors(vari, dims = 1:z); 
  vari <- FindClusters(vari, resolution = res) #for rishis ref/a you get 8 clusters with 0.15 resolution which needs to be checked against monocle3 pseudotime so that you do not get loops, 0.2-0.8
  vari <- RunUMAP(vari, dims = 1:z,return.model=TRUE)#This runs like a minute...
  cal=0:(dim(table ( Idents( vari) ))-1); cyl=1:dim(table ( Idents( vari) ));current.cluster.ids <- cal; new.cluster.ids <- cyl;vari@active.ident <- plyr::mapvalues(x =  vari@active.ident , from = current.cluster.ids, to = new.cluster.ids);
  vari$seurat_clusters <- plyr::mapvalues(x =  vari$seurat_clusters , from = current.cluster.ids, to = new.cluster.ids);
  printe=DimPlot( data, reduction = "umap",pt.size = 1, label = TRUE, label.size = 7,group.by = 'seurat_clusters');dev.off()
  print(printe);jpeg("Clusters in UMAP.png", width = 12000, height = 12000, pointsize = 16, res=1200);print(printe);dev.off()
  return(c(vari,z))}

#If you know that you have e.g. one epithelial cluster and one mesenchymal cluster, you could aim to see those by changing the below variables...
Cluster_iteration = function (data,PC,rs,cond) {
  data <- RunPCA(data, npcs=50,verbose = FALSE); #I have not used more than 50 pcs
  ElbowPlot(object = data, ndims = 50)
  pct <- data[["pca"]]@stdev / sum(data[["pca"]]@stdev) * 100
  cumu <- cumsum(pct); co1 <- which(cumu > 90 & pct < 5)[1]
  co2 <- sort(which((pct[1:length(pct) - 1] - pct[2:length(pct)]) > 0.1), decreasing = T)[1] + 1
  pcs <- min(co1, co2);co1;co2;pcs
  plot_df <- data.frame(pct = pct,cumu = cumu,rank = 1:length(pct))
  printa=ggplot(plot_df, aes(cumu, pct, label = rank, color = rank > pcs)) + geom_text() + geom_vline(xintercept = 99, color = "grey") + geom_hline(yintercept = min(pct[pct > 1]), color = "grey") +theme_bw();
  print(printa); png("PCs in elbow.png", width = 9000, height = 9000,pointsize = 16, res=1200);print(printa);dev.off() #olipas haasteellista;https://www.programiz.com/r/print-output
  #14 was perhaps too low I think, and from 19... starts clearly uniform
  if (PC=='Default') {z=pcs} else if (cond=='big') {if (pcs<27) {z=pcs+round(pcs*0.5)+5} else {z=pcs+3}} else {z=PC}
  #this defines much of the shape.. if you are expecting low numbers of clusters, this should be low, or in the beginning
  data <- RunUMAP(data, dims = 1:z,return.model=TRUE) #seed.use = saved.seed, huom. without seed.use estimate, basically no matter,
  data <- FindNeighbors(data, dims = 1:z) #  data@meta.data= data@meta.data[, c(1:15)]
  if (rs=='Default') {res=0.5} else if (rs=='big') {if (z<90) {res=0.4+round(z/80,2)} else if (z >= 90 ) {res=1.5}} else {res=rs}#divides the shape to smaller or bigger pieces:
  data <- FindClusters(data, resolution = res) #0.5//0.7/0.8/1 is good for pseudo check the final resolution for clustera and also from above 'hei',
  cal=0:(dim(table ( Idents( data) ))-1); cyl=1:dim(table ( Idents( data) ));current.cluster.ids <- cal; new.cluster.ids <- cyl; #or e.g.:
  data@active.ident <- plyr::mapvalues(x =  data@active.ident , from = current.cluster.ids, to = new.cluster.ids);
  data$seurat_clusters <- plyr::mapvalues(x =  data$seurat_clusters , from = current.cluster.ids, to = new.cluster.ids);# 'https://github.com/bicciatolab/popsicleR/blob/main/R/popsicleR.R'
  printe=DimPlot( data, reduction = "umap",pt.size = 1, label = TRUE, label.size = 7,group.by = 'seurat_clusters');dev.off() #group.by = 'seurat_clusters', SCT_snn_res.0.3
  print(printe);jpeg("Clusters in UMAP.png", width = 12000, height = 12000, pointsize = 16, res=1200);print(printe);dev.off()
  return(c(data,z))}

dispersion_removal=function(vari) {
  doni=c(); varin=vari
  clusta=length(table ( Idents( varin) ))
  DimPlot(varin,reduction="umap",pt.size = 1.5, label = TRUE, label.size = 7, group.by = 'seurat_clusters', order=FALSE) #Check the names...
  varin@meta.data=varin@meta.data[,1:28] #Check this..
  head(varin@meta.data)
  xlt=c();ylt=c()
  for (i in 1:clusta) {
    m3=subset(x = vari, idents = c(i))
    xm=ceiling(mean(m3@reductions$umap[[,1]]))
    ym=ceiling(mean(m3@reductions$umap[[,2]]))
    xl1=ceiling(sd(m3@reductions$umap[[,1]])*2.5)/2*1.05
    yl1=ceiling(sd(m3@reductions$umap[[,2]])*2.5)/2*1.05
    xlt=append(xlt,xl1); ylt=append(ylt,yl1)
    m33=m3[,m3@reductions$umap[[,1]]>(xm+xl1) | m3@reductions$umap[[,1]]<(xm-xl1)]
    m33b=m3[,m3@reductions$umap[[,2]]>(ym+yl1) | m3@reductions$umap[[,2]]<(ym-yl1)] #just check that clusta is high..# tryCatch( m33=m3[,m3@reductions$umap[[,1]]>(xm+xl1) | m3@reductions$umap[[,1]]<(xm-xl1)],# warning = function(w) {print(paste("No cells in cluster", i))}, error = function(e) { next })
    tot=unique(c(colnames(m33),colnames(m33b)))
    doni=append(doni,tot)}
  xmv=c();ymv=c()
  for (i in 1:clusta) {
    m3=subset(x = vari, idents = c(i))
    xm=ceiling(mean(m3@reductions$umap[[,1]]))
    ym=ceiling(mean(m3@reductions$umap[[,2]])) #two times the same thing...
    xmv=append(xmv,xm);ymv=append(ymv,ym) }
  varin=vari
  varin@meta.data=varin@meta.data[,1:28] #check this...
  va1=dim(varin@meta.data)[2]+1
  va2=dim(varin@meta.data)[2]+2
  varin@meta.data[,va1:va2]=varin@reductions$umap[[,1:2]]
  varin@meta.data[,va1:va2]=varin@reductions$umap[[,1:2]] 
  colnames(varin@meta.data)[va1] = 'UMAP_1'
  colnames(varin@meta.data)[va2] = 'UMAP_2'
  cluste=c(); #jups=data.frame()# Defining euclidean distance between two points
  euc.dist <- function(x1, x2) sqrt(sum((x1 - x2) ^ 2))
  for (i in 1:clusta) {
    for (j in 1:length(doni)) {
      pt1 <- varin@meta.data[colnames(varin) %in% doni,c('UMAP_1','UMAP_2','seurat_clusters')][j,1:2]# Defining the point 2 with x = 4 and y=1
      pt2 <- data.frame(x = xmv[i],y = ymv[i]); dist<- euc.dist(pt1,pt2); cluste=append(cluste,dist)}} # Calculating euclidean distance.. if you have many datapoints, this will take some time, 14:47-14:51 (for 1600 cells)
  nexus=array(cluste, dim = c(length(doni), clusta)); 
  nexus=data.frame(nexus); colnames(nexus)=1:clusta; # nexus[1:10,1:7]
  zap=c(); for (i in 1:length(doni)) {zap=append(zap,colnames(nexus)[nexus[i,]==min(nexus[i,])])} #these are the closest cells
  varin@meta.data[colnames(varin) %in% doni, c('seurat_clusters')]=as.numeric(zap) #this is not happening sometimes because of the below line:
  #varin$seurat_clusters =factor(x = Idents(varin), levels = 1:clusta) #this may or may not be needed...far from obvious, but was done app.r as: https://github.com/satijalab/seurat/issues/1697, https://mojaveazure.github.io/seurat-object/reference/Idents.html
  # table(varin$seurat_clusters) # vari2 <- subset(x = varin, idents = 1:13)
  DimPlot(varin, label = TRUE, label.size = 7,pt.size = 3,group.by = 'seurat_clusters') #+ xlim(-11,-2)#+ xlim(-4,4)+ylim(7,9)+ ggtitle("") #remember to add group.by = 'seurat_clusters' or Sub_cluster
  return(varin)}

```

# Execution of Preprocessing and Initial Analysis
```{r, warning=FALSE,message=FALSE,fig.width=8.0}

#For this you need to have Datalist, data, the name for saving, and mc for number of cell in minimum sample (if less than 100, and if above then 100)
DefaultAssay(data1aa) <- "RNA"; DataList1 <- SplitObject(data1aa, split.by = "orig.ident") #DataList is made from the filtered data, but check manually if any of the sets are less than 80 
DefaultAssay(data2aa) <- "RNA"; DataList2 <- SplitObject(data2aa, split.by = "orig.ident") #DataList is made from the filtered data, but check manually if any of the sets are less than 80 
DefaultAssay(data3aa)  <- "RNA"; DataList3 <- SplitObject(data3aa, split.by = "orig.ident")

#This is where you want to save the whole environment, unless you want to do the loading and processing every time, which is like 15min per stage, i.e. like 1h
# save.image("C:/Users/patati/Desktop/TurkuOW/RWork/all.RData")
# load("C:/Users/patati/Desktop/TurkuOW/RWork/all.RData")

#This works for E11 and E14:
mc=100#min cell number, sample 1 and 2
date1=Transform1(DataList1,mc,case='E14') #Check your case.. #Needs to be regressed at least: "G2M.Score","S.Score",percent.mt,percent.link
#this is now second version of the total merge... with transfrom2 and filter to two experiments otherwise differently
date1[[1]]; date1[[2]]; date1[[3]]; 
Data1=datajei # or of course...date1[[1]]; 
Data1[c('Sox2','Pitx2'),]
name=paste('E11.5_int_ok',namedate,'.rds'); saveRDS(Data1, name) #check the name..

# date1o <- readRDS(file = "E14.25_int_ok1_big1 Tikka 5.7.23 .rds")
if ((min(table(data2a$orig.ident))-1)>100) {mc=100} else mc=min(table(data2a$orig.ident))-1;mc #min cell number -1 or more... # 
date2=Transform1(DataList2,mc,case='E14')
date2[[1]]; date2[[2]]; date2[[3]]; Data2=date2[[1]]
name=paste('E14.25_int_ok',namedate,'.rds'); saveRDS(Data2, name)

#For E16,#this is probably ok:
DefaultAssay(data3)  <- "RNA";
mc=100 #Check from DataList
date3=Transform1(DataList3,mc, case='E16')
date3[[1]]; date3[[2]]; date3[[3]]; Data3=date3[[1]]
name=paste('E16.5_int_ok',namedate,'.rds'); saveRDS(Data3, name) #check the name..





```

# Execution of Initial Analysis
```{r, warning=FALSE,message=FALSE,fig.width=8.0}

# DefaultAssay( Data1) <- "integrated" 
PC='Default' #Default/'number'/'nothing'
cond='no' #if big then
rs=0.7;latex=c();  #Default, or 0.7 or 1.07 produces the smaller nub '18', but 1.05/6.. not or 2-10 #2.4 ->10"
latex=Cluster_iteration(Data1,PC,rs,cond) #Check if it is data or data1 or data2 etc.
Data1=latex[[1]]; latex[[2]] #This is the combined epithelia!
DimPlot(Data1,reduction="umap",pt.size = 2, label = TRUE, label.size = 7,group.by = 'seurat_clusters')#+ xlim(-11,-2)#+ xlim(-4,4)+ylim(7,9)+ ggtitle("")
# vars=c('Pitx2','Sox2','Shh','Vim');
DefaultAssay( Data1) <- "SCT" 
vars=c('Pitx2','Sox2','Shh','Acta2','Cdh5','Vim');
DefaultAssay( Data1) <- "SCT" 
FeaturePlot(Data1, features = vars,cols = c("#c0c0c0",'red'),pt.size = 1,order=TRUE,min.cutoff=0,ncol=3, split.by=NULL)

saveRDS(Data1, file = paste('E14.25_epi_int',namedate,'.rds')) # datto2 = readRDS(file = "E11.5_double int_r0.15_pc8_ptt30323.rds")


```



